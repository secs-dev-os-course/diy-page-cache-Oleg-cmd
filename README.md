# Лабораторная работа #2 по ОС

## Build options

В корне проекта:

1. Выполнить конфигурацию проекта и положить конфиги в каталог `build`:
```shell
cmake -B build
|
cmake -DDEBUG_CACHE=ON -S . -B build

2. Собрать проект с использованием подготовленной конфигурации в каталоге `build`:
```shell
cmake --build build
```

- - -

# Отчет

P3314 Селянта Олег Дмитриевич

Базовый трек, оценка 3. ЛР 2. Page Cache

Вариант: Linux, Clock

## Описание изменений

* **Реализация блочного кэша:** Разработан блочный кэш в виде динамической библиотеки (`libdiy_cache.so`) в директории `/source/diy_cache`.  Кэш реализует политику вытеснения Clock.

* **API для работы с кэшем:**  Создан простой API  для работы с файлами через кэш,  включающий функции `lab2_open`, `lab2_close`, `lab2_read`, `lab2_write`, `lab2_lseek`, и `lab2_fsync`, объявленные в `/source/diy_cache/lab2_api.h`.

* **Адаптация программы-загрузчика:**  Адаптирована программа-загрузчик из ЛР1 (бенчмарки `EmaSearchInt` и `EmaLinregBench`) для использования разработанного блочного кэша. Изменения внесены в файлы `/benchmarks/search_benchmark.cpp` и `/benchmark/linreg_benchmark.cpp`.  Теперь эти бенчмарки используют функции `lab2_*` вместо стандартных функций работы с файлами. Старые бенчмарки именованы с префиксом `pure_`. Исполняемые бенчмарки именованы с постфиксом `_ex`

* **Тестирование:** Написаны unit-тесты для проверки корректности работы `Storage`  (класса для работы с файлами в обход page cache ОС).  Тесты находятся в `/tests/storage_test.cpp`.

* **Логические шаги решения:**
    1. Реализация класса `Storage` для работы с файлами,  используя `pread` и `pwrite`.
    2. Разработка класса `Page` для представления страницы кэша.
    3. Реализация класса `Cache` с политикой вытеснения Clock.
    4. Создание API (`lab2_api.*`) для взаимодействия с кэшем.
    5. Адаптация бенчмарков для использования API.
    6. Написание unit-тестов.
    7. Тестирование и отладка.
    8. Написание отчета.



## Краткий обзор кода

Код реализует блочный кэш в пространстве пользователя с политикой вытеснения Clock и дополнительной возможностью выбора оптимальных параметров кэша (Optimal режим).

**Основные компоненты:**

* **`Storage` (`storage.h/.cpp`):** Класс для работы с файлами в обход системного кэша, используя `pread` и `pwrite`.  Обеспечивает низкоуровневый доступ к диску.
* **`Page` (`page.h/.cpp`):**  Класс, представляющий страницу кэша. Хранит данные страницы, её смещение в файле, флаги "грязная" (изменена) и "accessed" (использовалась).
* **`Cache` (`cache.h/.cpp`):**  Основной класс, реализующий логику кэширования.  Использует `std::list` для организации списка страниц и `std::unordered_map` для быстрого доступа к страницам по смещению.  Реализует политику вытеснения Clock.  Методы `read`, `write`, `sync` взаимодействуют со `Storage` для чтения/записи данных.
* **`lab2_api` (`lab2_api.h/.cpp`):**  API, предоставляющий функции `lab2_open`, `lab2_close`, `lab2_read`, `lab2_write`, `lab2_lseek`, `lab2_fsync` для работы с кэшем.  Использует  глобальные переменные для хранения  экземпляра кэша и  информации о  файлах.
* **Бенчмарки (`/benchmarks`):** Адаптированные  бенчмарки `EmaSearchInt` и `EmaLinregBench` из ЛР1,  использующие `lab2_api` для  работы с файлами.
* **Тесты (`/tests`):** Unit-тесты для класса `Storage`, проверяющие корректность чтения и записи данных.


**Optimal режим:**

В коде присутствует функционал для тестирования различных параметров кэша (размер блока, размер страницы, размер кэша) и выбора оптимальных значений. Это реализовано в  файле `/app/optimal.cpp`.  Функция `RunBenchmarks` запускает  бенчмарки с  различными  комбинациями  параметров  и  сохраняет  результаты  (время  выполнения).  Затем  результаты  сортируются,  и  выводятся  5  лучших  конфигураций.  Это позволяет  эмпирически  определить  наиболее  эффективные  параметры  кэша  для  данных  нагрузчиков.


**Основные структуры данных:**

* `std::list<Page>` в классе `Cache`:  хранит страницы кэша.
* `std::unordered_map<off_t, std::list<Page>::iterator>` в классе `Cache`:  отображает смещение страницы в файле на  итератор в  списке страниц.


**Алгоритм Clock:**

Алгоритм Clock реализован в методе `evict` класса `Cache`.  При необходимости вытеснения страницы,  алгоритм  проходит  по  списку  страниц  и  сбрасывает  флаг `accessed`.  Если  флаг  уже  сброшен,  страница  вытесняется.  Если  все  страницы  имеют  установленный  флаг  `accessed`,  алгоритм  проходит  по  списку  ещё  раз,  вытесняя  первую  встретившуюся  страницу.


int iterations = 100;
    std::size_t num_points = 1000;
    std::size_t num_elements = 1000;
    int min_value = 0;
    int max_value = 2000;



## Фактические результаты программы-загрузчика с анализом

Этот раздел содержит более подробный анализ результатов работы бенчмарков `EmaLinregBench` и `EmaSearchInt` до и после внедрения блочного кэша, включая объяснение причин наблюдаемых изменений производительности.

**Параметры тестирования:**

* `iterations = 100`
* `num_points = 1000` (для `EmaLinregBench`)
* `num_elements = 1000` (для `EmaSearchInt`)
* `min_value = 0` (для `EmaSearchInt`)
* `max_value = 2000` (для `EmaSearchInt`)


### EmaLinregBench

| Режим        | Среднее время выполнения (секунды) | Улучшение производительности |
|--------------|------------------------------------|------------------------------|
| Без кэша (запуск 1)   | 0.0006274           | -                           |
| Без кэша (запуск 2)   | 0.0005927          | -                            |
| Без кэша (среднее)   | 0.00061             | 0% (базовая линия)         |
| С кэшем (PageSize: 8192, CacheSize: 500, BlockSize: 8192)    | 0.0000250369      | ~96% (в в 24 раза)                           |
| С кэшем (PageSize: 16384, CacheSize: 20, BlockSize: 8192) | 0.0000251454     | ~96% (в в 24 раза)                              |


**Анализ `EmaLinregBench`:**

Линейная регрессия осуществляет последовательное чтение данных из файла.  Без кэша каждое чтение приводит к обращению к диску, что является  операцией с  высокой  латентностью.  Блочный кэш  значительно  уменьшает количество  обращений к диску за счет хранения  часто  используемых  данных  в оперативной памяти.

Наблюдаемое  96%  улучшение  производительности  подтверждает  эффективность  кэширования  для  последовательного  доступа  к  данным. Интересно, что  даже  при  относительно  небольшом  размере кэша (CacheSize: 20),  но с большим размером страницы (PageSize: 16384), производительность  остается  высокой. Это  объясняется тем, что  больший размер страницы позволяет  загружать в кэш больше  последовательных данных,  что  увеличивает вероятность  попадания  (хит-рейт)  при  последовательном чтении.  Наилучший  результат  получен  при  большом  размере  кэша (CacheSize: 500) и  страницы (PageSize: 8192),  что  позволило практически полностью  уместить  рабочий  набор  данных  в  кэше.



### EmaSearchInt


| Режим        | Среднее время выполнения (секунды) | Улучшение производительности |
|--------------|------------------------------------|------------------------------|
| Без кэша (запуск 1)   | 0.0000408955          | -                           |
| Без кэша (запуск 2)   | 0.0000434554           | -                           |
| Без кэша (среднее)   | 0.000042             | 0% (базовая линия)         |
| С кэшем (PageSize: 8192, CacheSize: 5, BlockSize: 256) | 0.00000215457       | ~95% (в 19 раз)                  |
| С кэшем (PageSize: 4096, CacheSize: 500, BlockSize: 256)| 0.00000217245       | ~95%  (в 19 раз)                        |


**Анализ `EmaSearchInt`:**

В  отличие  от  линейной  регрессии,  бенчмарк  поиска  характеризуется  более  случайным  доступом  к  данным.  В  худшем  случае,  когда  искомый  элемент  находится  в  конце  файла  или  отсутствует,  приходится  прочитать  весь  файл.  Однако,  кэш  все  равно  дает  значительное  улучшение  производительности (95%),  даже  при  небольшом  размере  кэша (CacheSize: 5). Это  указывает  на  то,  что  даже  при  случайном  доступе,  часть  данных  попадает  в  кэш,  что  сокращает  количество  обращений  к диску.  Интересно,  что  больший  размер  кэша (CacheSize: 500)  не  приводит  к  существенному  дополнительному  ускорению.  Это  можно  объяснить  тем, что  при  случайном  доступе,  вероятность  повторного  попадания  в  кэш  меньше,  чем  при  последовательном  чтении,  поэтому  увеличение  размера  кэша  дает  меньший  эффект.  Маленький  размер  блока (BlockSize: 256)  оказался  оптимальным,  вероятно,  из-за  меньших  накладных расходов  на  чтение  и  запись  блоков.


**Новые параметры тестирования:**

* `iterations = 100`
* `num_points = 10000` (для `EmaLinregBench`)
* `num_elements = 10000` (для `EmaSearchInt`)
* `min_value = 0` (для `EmaSearchInt`)
* `max_value = 20000` (для `EmaSearchInt`)

### EmaLinregBench (10000 точек)

| Режим        | Среднее время выполнения (секунды) | Улучшение производительности |
|--------------|------------------------------------|------------------------------|
| Без кэша    | 0.0047042            | 0%                           |
| С кэшем (PageSize: 16384, CacheSize: 10, BlockSize: 8192)    | 0.000243031      | ~95%                           |


**Анализ `EmaLinregBench` (10000 точек):**

Увеличение объема данных до 10000 точек  подтверждает  предыдущие  наблюдения.  Кэш по-прежнему обеспечивает  значительное  улучшение  производительности (~95%).  Интересно,  что  даже  при  небольшом  размере  кэша (CacheSize: 10)  и большом размере страницы (PageSize: 16384) удается достичь  высокой  эффективности. Стоит отметить, что `Cache size` в данном случае не влияет на производительность, и при больших значениях (и таком же размере страницы) среднее время выполнения не увеличивается. Это  подтверждает  важность  большого  размера  страницы для последовательного чтения,  так  как  она  позволяет  удерживать  в  кэше  большее  количество  подряд  идущих  данных.  С  ростом объема данных, абсолютный выигрыш от использования кэша становится еще более  заметным (с нескольких микросекунд до нескольких миллисекунд).


### EmaSearchInt (10000 элементов)

| Режим        | Среднее время выполнения (секунды) | Улучшение производительности |
|--------------|------------------------------------|------------------------------|
| Без кэша    | 0.000355836            | 0%                           |
| С кэшем (PageSize: 16384, CacheSize: 200, BlockSize: 1024)  | 0.00000297007       | ~99%                         |


**Анализ `EmaSearchInt` (10000 элементов):**

С увеличением  количества  элементов  до  10000,  производительность  с  кэшем  также  значительно  возрастает  (~99%  улучшение).  В этом случае  наилучший  результат  получен  при  большом  размере  страницы  (PageSize: 16384),  большом  размере  кэша (CacheSize: 200) и среднем  размере  блока (BlockSize: 1024), однако очень стоит упомянуть что почти таких же результатов в скорости добилась конфигурация с Page size: 8192, Cache size: 2, Block size: 1024, что говорит о том, что самый лучший с точки зрения производительности вариант не всегда является самым оптимальным по соотношению скорости работы и потребления памяти.  Увеличение  размера  кэша  в  этом  случае  дает  более  заметный  эффект, чем  с  меньшим  количеством  элементов,  вероятно,  потому, что  с  большим  объемом  данных  возрастает  вероятность  попадания  в  кэш  даже  при  случайном  доступе.


## Общий вывод по результатам

Проведенные  тесты  демонстрируют  высокую  эффективность  разработанного  блочного  кэша  как  для  последовательного,  так и для  случайного  доступа  к  данным.  Кэш  позволяет  значительно  сократить  количество  обращений  к  диску, что  приводит к  существенному  ускорению работы  приложений.

**Ключевые наблюдения:**

* **Влияние размера страницы:**  Больший размер страницы  более  выгоден  для  последовательного  чтения, так как  позволяет  загружать  большие  блоки  данных  и  увеличивает  вероятность  попадания  в  кэш.

* **Влияние размера кэша:**  Увеличение  размера  кэша,  как  правило,  повышает  производительность,  но  эффект  более  заметен  для  последовательного  чтения.  Для  случайного  доступа  выигрыш  от  очень  большого  кэша  может  быть  менее  значительным.

* **Влияние размера блока:**  Оптимальный  размер  блока  зависит  от  характера  нагрузки.  Для  `EmaSearchInt`  меньший  размер  блока  оказался  более  эффективным.

* **Масштабируемость:**  С  увеличением  объема  данных,  абсолютный  выигрыш  от  использования  кэша  возрастает,  что  подтверждает  его  эффективность  для  работы  с  большими  файлами.


## Достойно упоминания
### Закономерность размера блока

В ходе экспериментов было обнаружено интересное явление: для каждого бенчмарка, при фиксированных остальных параметрах, оптимальный размер блока (BlockSize) остается практически неизменным в топ-5 самых быстрых конфигураций.  Это наблюдение заслуживает отдельного внимания и анализа.


**Возможные объяснения:**

* **Специфика бенчмарков:**  Каждый бенчмарк имеет свой характер доступа к данным. `EmaLinregBench` осуществляет последовательное чтение,  поэтому  большой размер блока позволяет  считывать  больше  данных  за  одно  обращение  к  кэшу  (или  диску,  если  данных  нет  в  кэше).  `EmaSearchInt`  выполняет  поиск  конкретного  элемента,  и  меньший  размер  блока  позволяет  быстрее  проверить  наличие  элемента  в  блоке,  минимизируя  объем  считываемых  данных.

* **Накладные расходы:** Чтение  и  запись  блоков  данных  связаны  с  определенными  накладными  расходами.  Слишком  маленький  размер  блока  приведет  к  большому  количеству  операций  чтения/записи,  что  увеличит  накладные  расходы.  Слишком  большой  размер  блока  может  привести  к  загрузке  ненужных  данных  и  более  длительному  ожиданию  при  чтении  с  диска.

* **Особенности аппаратного обеспечения:** Размер блока  может  быть  оптимальным  для  конкретного  аппаратного  обеспечения  (например,  размер  сектора  диска  или  размер  блока  памяти).


**Философские мысли:**

Наблюдаемая  стабильность  размера  блока  указывает  на  существование  некоторого  баланса  между  эффективностью  чтения/записи  данных  и  накладными  расходами.  Этот  баланс  определяется  характером  нагрузки  и  параметрами  аппаратного  обеспечения.  
