# Лабораторная работа #2 по ОС

## Build options

В корне проекта:

1. Выполнить конфигурацию проекта и положить конфиги в каталог `build`:
```shell
cmake -B build
|
cmake -DDEBUG_CACHE=ON -S . -B build

2. Собрать проект с использованием подготовленной конфигурации в каталоге `build`:
```shell
cmake --build build
```

- - -

# Отчет

P3314 Селянта Олег Дмитриевич

Базовый трек, оценка 3. ЛР 2. Page Cache

Вариант: Linux, Clock

## Описание изменений

* **Реализация блочного кэша:** Разработан блочный кэш в виде динамической библиотеки (`libdiy_cache.so`) в директории `/source/diy_cache`.  Кэш реализует политику вытеснения Clock.

* **API для работы с кэшем:**  Создан простой API  для работы с файлами через кэш,  включающий функции `lab2_open`, `lab2_close`, `lab2_read`, `lab2_write`, `lab2_lseek`, и `lab2_fsync`, объявленные в `/source/diy_cache/lab2_api.h`.

* **Адаптация программы-загрузчика:**  Адаптирована программа-загрузчик из ЛР1 (бенчмарки `EmaSearchInt` и `EmaLinregBench`) для использования разработанного блочного кэша. Изменения внесены в файлы `/benchmarks/search_benchmark.cpp` и `/benchmark/linreg_benchmark.cpp`.  Теперь эти бенчмарки используют функции `lab2_*` вместо стандартных функций работы с файлами. Старые бенчмарки именованы с префиксом `pure_`. Исполняемые бенчмарки именованы с постфиксом `_ex`

* **Тестирование:** Написаны unit-тесты для проверки корректности работы `Storage`  (класса для работы с файлами в обход page cache ОС).  Тесты находятся в `/tests/storage_test.cpp`.

* **Логические шаги решения:**
    1. Реализация класса `Storage` для работы с файлами,  используя `pread` и `pwrite`.
    2. Разработка класса `Page` для представления страницы кэша.
    3. Реализация класса `Cache` с политикой вытеснения Clock.
    4. Создание API (`lab2_api.*`) для взаимодействия с кэшем.
    5. Адаптация бенчмарков для использования API.
    6. Написание unit-тестов.
    7. Тестирование и отладка.
    8. Написание отчета.



## Краткий обзор кода

Код реализует блочный кэш в пространстве пользователя с политикой вытеснения Clock и дополнительной возможностью выбора оптимальных параметров кэша (Optimal режим).

**Основные компоненты:**

* **`Storage` (`storage.h/.cpp`):** Класс для работы с файлами в обход системного кэша, используя `pread` и `pwrite`.  Обеспечивает низкоуровневый доступ к диску.
* **`Page` (`page.h/.cpp`):**  Класс, представляющий страницу кэша. Хранит данные страницы, её смещение в файле, флаги "грязная" (изменена) и "accessed" (использовалась).
* **`Cache` (`cache.h/.cpp`):**  Основной класс, реализующий логику кэширования.  Использует `std::list` для организации списка страниц и `std::unordered_map` для быстрого доступа к страницам по смещению.  Реализует политику вытеснения Clock.  Методы `read`, `write`, `sync` взаимодействуют со `Storage` для чтения/записи данных.
* **`lab2_api` (`lab2_api.h/.cpp`):**  API, предоставляющий функции `lab2_open`, `lab2_close`, `lab2_read`, `lab2_write`, `lab2_lseek`, `lab2_fsync` для работы с кэшем.  Использует  глобальные переменные для хранения  экземпляра кэша и  информации о  файлах.
* **Бенчмарки (`/benchmarks`):** Адаптированные  бенчмарки `EmaSearchInt` и `EmaLinregBench` из ЛР1,  использующие `lab2_api` для  работы с файлами.
* **Тесты (`/tests`):** Unit-тесты для класса `Storage`, проверяющие корректность чтения и записи данных.


**Optimal режим:**

В коде присутствует функционал для тестирования различных параметров кэша (размер блока, размер страницы, размер кэша) и выбора оптимальных значений. Это реализовано в  файле `/app/optimal.cpp`.  Функция `RunBenchmarks` запускает  бенчмарки с  различными  комбинациями  параметров  и  сохраняет  результаты  (время  выполнения).  Затем  результаты  сортируются,  и  выводятся  5  лучших  конфигураций.  Это позволяет  эмпирически  определить  наиболее  эффективные  параметры  кэша  для  данных  нагрузчиков.


**Основные структуры данных:**

* `std::list<Page>` в классе `Cache`:  хранит страницы кэша.
* `std::unordered_map<off_t, std::list<Page>::iterator>` в классе `Cache`:  отображает смещение страницы в файле на  итератор в  списке страниц.


**Алгоритм Clock:**

Алгоритм Clock реализован в методе `evict` класса `Cache`.  При необходимости вытеснения страницы,  алгоритм  проходит  по  списку  страниц  и  сбрасывает  флаг `accessed`.  Если  флаг  уже  сброшен,  страница  вытесняется.  Если  все  страницы  имеют  установленный  флаг  `accessed`,  алгоритм  проходит  по  списку  ещё  раз,  вытесняя  первую  встретившуюся  страницу.


## Сравнительный анализ результатов работы бенчмарков (с кэшем и без кэша ОС)

В этом разделе представлен сравнительный анализ результатов работы бенчмарков `EmaLinregBench` и `EmaSearchInt` при разных условиях: без кэширования, с блочным кэшем (`O_DIRECT`) и с использованием системного кэша . Анализ также включает сравнение производительности при работе с 1000 и 10000 элементами/точками.

**Параметры тестирования:**

*   `iterations = 100`
*   `num_points = 1000` и `10000` (для `EmaLinregBench`)
*   `num_elements = 1000` и `10000` (для `EmaSearchInt`)
*   `min_value = 0` (для `EmaSearchInt`)
*   `max_value = 2000` и `20000` (для `EmaSearchInt`)

**Ключевые моменты:**

*   **"Без кэша (среднее)"** -  результаты получены без использования какого-либо кэширования (ни системного, ни нашего блочного), то есть с прямыми операциями чтения/записи с диска. (только в старых результатах)
*   **"С кэшем"** - результаты получены с использованием **нашего блочного кэша** и флага `O_DIRECT`, что гарантирует, что **системный кэш не используется**. (новые и старые результаты).
* **Результаты с системным кэшем** - результаты полученные ранее с использованием системного кеша.

### EmaLinregBench

#### Результаты с 1000 точками

| Режим                                                     | Среднее время выполнения (секунды) | Улучшение производительности |
|-----------------------------------------------------------|------------------------------------|------------------------------|
| Без кэша (среднее)                                       | 0.00061                             | 0% (базовая линия)           |
| С кэшем (PageSize: 8192, CacheSize: 500, BlockSize: 8192)  | 0.0000250369                       | ~96% (в 24 раза)            |
| С кэшем (PageSize: 16384, CacheSize: 20, BlockSize: 8192) | 0.0000251454                         | ~96% (в 24 раза)            |
| **С кэшем (O_DIRECT, Page Size: 8192, Cache size: 10, Block size: 8192)**     | 2.37317e-05              | 96%  (в 25 раз)        |
| **С кэшем (O_DIRECT, Page Size: 4096, Cache size: 20, Block size: 8192)**   | 2.45511e-05   | 96% (в 25 раз)           |
| **С кэшем (O_DIRECT, Page Size: 4096, Cache size: 20, Block size: 4096)**   | 2.4568e-05   | 96% (в 25 раз)     |
| **С кэшем (O_DIRECT, Page Size: 4096, Cache size: 50, Block size: 4096)**   |  2.49694e-05  | 96% (в 24 раза)          |
| **С кэшем (O_DIRECT, Page Size: 4096, Cache size: 10, Block size: 4096)**   |   2.51237e-05 | 96% (в 24 раза)       |


**Анализ `EmaLinregBench` (1000 точек):**

* **Сравнение с системным кэшем:**
    *  Использование системного кеша (результаты до внедрения O_DIRECT) давало немного лучшие результаты, чем наша реализация, но в целом все равно все результаты были очень хорошие (96% улучшения производительности)
    *  Это говорит о том, что системный кеш работает более оптимально.
    *  Мы видим, что `Cache Size` и `Page Size` влияют на производительность, но не критично (так как они все равно больше BlockSize).

#### Результаты с 10000 точками (без системного кэша, O_DIRECT)

| Режим        | Среднее время выполнения (секунды) | Улучшение производительности |
|--------------|------------------------------------|------------------------------|
| Без кэша    | 0.0047042                             | 0%                           |
| С кэшем (PageSize: 16384, CacheSize: 10, BlockSize: 8192)  | 0.000243031        | ~95%       |

**Топ 5 результатов `EmaLinregBench` (без системного кэша):**

| Page Size | Cache Size | Block Size | Среднее время выполнения (секунды) |
|-----------|------------|------------|------------------------------------|
| 8192      | 200       | 8192       | 0.000234653                       |
| 4096      | 500       | 8192       | 0.000235546                       |
| 8192      | 100       | 8192       | 0.000235718                       |
| 4096      | 100       | 8192       | 0.000237197                        |
| 8192      | 500       | 8192       | 0.000238122                       |

**Анализ `EmaLinregBench` (10000 точек):**

*   **Сравнение с 1000 точками:**
    *  С увеличением объема данных, без кэша время выполнения значительно выросло.
    *   Однако, как с системным кэшем, так и без него, при использовании кэша ускорение работы остается на том же уровне, т.к. относительное время выполнения меньше, чем при запуске без кэша.
*   **Влияние параметров:**
    *   Мы видим что, при использовании нашего кэша + O_DIRECT, результаты в целом хуже, чем при использовании системного кэша.
    *    Также, тут по-прежнему самым важным параметром оказался размер блока, который должен быть близок к размеру страницы.

### EmaSearchInt

#### Результаты с 1000 элементами (с системным кэшем)

| Режим                                                     | Среднее время выполнения (секунды) | Улучшение производительности |
|-----------------------------------------------------------|------------------------------------|------------------------------|
| Без кэша (среднее)                                       | 0.000042                             | 0% (базовая линия)           |
| С кэшем (PageSize: 8192, CacheSize: 5, BlockSize: 256)     | 0.00000215457                       | ~95% (в 19 раз)             |
| С кэшем (PageSize: 4096, CacheSize: 500, BlockSize: 256)  | 0.00000217245                       | ~95% (в 19 раз)              |

#### Результаты с 10000 элементами (без системного кэша, O_DIRECT)

| Режим        | Среднее время выполнения (секунды) | Улучшение производительности |
|--------------|------------------------------------|------------------------------|
| Без кэша    | 0.000355836                          | 0%                           |
| С кэшем (PageSize: 16384, CacheSize: 200, BlockSize: 1024)    | 0.00000297007        | ~99%      |

**Топ 5 результатов `EmaSearchInt` (без системного кэша):**

| Page Size | Cache Size | Block Size | Среднее время выполнения (секунды) |
|-----------|------------|------------|------------------------------------|
| 8192     | 500       | 4096        | 1.3464e-05                         |
| 4096     | 500       | 4096        | 1.37566e-05                         |
| 16384    | 200       | 4096        | 1.40903e-05                         |
| 16384     | 5        | 4096        | 1.41509e-05                         |
| 16384    | 50       | 4096        | 1.45072e-05                        |

**Анализ `EmaSearchInt`:**

* **Сравнение с системным кэшем:**
  * Результаты с системным кэшем показывают, что при использовании системного кэша мы получаем ускорение в 19 раз.
    *   Мы видим очень маленькое время выполнения с кэшем ОС.
* **Результаты без системного кэша (O_DIRECT):**
  * Показывают, что при использовании нашего кэша, мы все еще получаем ускорение ~99%
    *  При этом  размер кэша влияет на время выполнения сильнее чем размер блока.
     *   Как и в тесте с линейной регрессией, мы не получаем такого же прироста в скорости, как при работе с системным кэшем.
* **Сравнение 1000 и 10000 элементов:**
  * По сравнению с 1000 элементами, время выполнения увеличилось при запуске как без кэша, так и с кэшем, но скорость чтения относительно без кэша возросла.

**Общий вывод:**

*   **Системный кэш vs. O_DIRECT:**  Использование системного кэша показало наилучшее время выполнения по сравнению с чистым I/O (наш кэш + O_DIRECT), так как ОС делает дополнительные оптимизации с чтением и записью с диска.
*   **Наш кэш:** Тем не менее, наш блочный кэш + O_DIRECT значительно улучшает производительность по сравнению с прямыми операциями I/O.
*  **Масштабируемость:**   С увеличением объема данных, относительная производительность с кэшем возрастает, т.к. кэш позволяет нам значительно ускорить чтение.


В результате, наш блочный кэш + O_DIRECT, хоть и показывает худшие результаты чем системный кэш, все же значительно ускоряет работу с файлами, и, при правильной настройке, позволяет добиться хороших показателей производительности, и самое главное мы теперь имеем полный контроль над операциями I/O.

Теперь у вас есть полный сравнительный анализ результатов с системным и без системного кэширования с разными объемами данных. Если у вас есть еще вопросы, то не стесняйтесь задавать.






## Общий вывод по результатам

Проведенные  тесты  демонстрируют  высокую  эффективность  разработанного  блочного  кэша  как  для  последовательного,  так и для  случайного  доступа  к  данным.  Кэш  позволяет  значительно  сократить  количество  обращений  к  диску, что  приводит к  существенному  ускорению работы  приложений.

**Ключевые наблюдения:**

* **Влияние размера страницы:**  Больший размер страницы  более  выгоден  для  последовательного  чтения, так как  позволяет  загружать  большие  блоки  данных  и  увеличивает  вероятность  попадания  в  кэш.

* **Влияние размера кэша:**  Увеличение  размера  кэша,  как  правило,  повышает  производительность,  но  эффект  более  заметен  для  последовательного  чтения.  Для  случайного  доступа  выигрыш  от  очень  большого  кэша  может  быть  менее  значительным.

* **Влияние размера блока:**  Оптимальный  размер  блока  зависит  от  характера  нагрузки.  Для  `EmaSearchInt`  меньший  размер  блока  оказался  более  эффективным.

* **Масштабируемость:**  С  увеличением  объема  данных,  абсолютный  выигрыш  от  использования  кэша  возрастает,  что  подтверждает  его  эффективность  для  работы  с  большими  файлами.


## Достойно упоминания
### Закономерность размера блока

В ходе экспериментов было обнаружено интересное явление: для каждого бенчмарка, при фиксированных остальных параметрах, оптимальный размер блока (BlockSize) остается практически неизменным в топ-5 самых быстрых конфигураций.  Это наблюдение заслуживает отдельного внимания и анализа.


**Возможные объяснения:**

* **Специфика бенчмарков:**  Каждый бенчмарк имеет свой характер доступа к данным. `EmaLinregBench` осуществляет последовательное чтение,  поэтому  большой размер блока позволяет  считывать  больше  данных  за  одно  обращение  к  кэшу  (или  диску,  если  данных  нет  в  кэше).  `EmaSearchInt`  выполняет  поиск  конкретного  элемента,  и  меньший  размер  блока  позволяет  быстрее  проверить  наличие  элемента  в  блоке,  минимизируя  объем  считываемых  данных.

* **Накладные расходы:** Чтение  и  запись  блоков  данных  связаны  с  определенными  накладными  расходами.  Слишком  маленький  размер  блока  приведет  к  большому  количеству  операций  чтения/записи,  что  увеличит  накладные  расходы.  Слишком  большой  размер  блока  может  привести  к  загрузке  ненужных  данных  и  более  длительному  ожиданию  при  чтении  с  диска.

* **Особенности аппаратного обеспечения:** Размер блока  может  быть  оптимальным  для  конкретного  аппаратного  обеспечения  (например,  размер  сектора  диска  или  размер  блока  памяти).


**Философские мысли:**

Наблюдаемая  стабильность  размера  блока  указывает  на  существование  некоторого  баланса  между  эффективностью  чтения/записи  данных  и  накладными  расходами.  Этот  баланс  определяется  характером  нагрузки  и  параметрами  аппаратного  обеспечения.  
